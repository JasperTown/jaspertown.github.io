<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasperTown的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-31T18:46:35.504Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JasperTown</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO</title>
    <link href="http://yoursite.com/2019/06/01/io/"/>
    <id>http://yoursite.com/2019/06/01/io/</id>
    <published>2019-05-31T18:42:22.995Z</published>
    <updated>2019-05-31T18:46:35.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul><li>流就是字节序列的抽象概念，能被连续读取数据的数据源和能被连续写入数据的接收端就是流，流机制是Java及C++中的一个重要机制，通过流我们可以自由地控制文件、内存、IO设备等数据的流向。而IO流就是用于处理设备上的数据，如：硬盘、内存、键盘录入等。IO流根据处理类型的不同可分为字节流和字符流，根据流向的不同可分为输入流和输出流。<h4 id="二-、字节流和字符流的区别"><a href="#二-、字节流和字符流的区别" class="headerlink" title="二 、字节流和字符流的区别"></a>二 、字节流和字符流的区别</h4></li><li>字符流，因为文件编码的不同，就有了对字符进行高效操作的字符流对象，它的原理就是基于字节流读取字节时去查了指定的码表。它和字节流的区别有两点：1.在读取数据的时候，字节流读到一个字节就返回一个字节，字符流使用了字节流读到一个或多个字节（一个中文对应的字节数是两个，在UTF-8码表中是3个字节）时，先去查指定的编码表，再将查到的字符<br>返回；</li><li>字节流可以处理所有类型的数据，如jpg、avi、mp3、wav等等，而字符流只能处理字符数据。所以可以根据处理的文件不同考虑使用字节流还是字符流，如果是纯文本数据可以优先考虑字符流，否则使用字节流。<h3 id="三、IO继承体系"><a href="#三、IO继承体系" class="headerlink" title="三、IO继承体系"></a>三、IO继承体系</h3><img src="./IO继承体系.png" alt="IO继承体系"><h4 id="IO流主要可以分为节点流和处理流两大类"><a href="#IO流主要可以分为节点流和处理流两大类" class="headerlink" title="IO流主要可以分为节点流和处理流两大类"></a>IO流主要可以分为节点流和处理流两大类</h4><h5 id="1-节点流类型"><a href="#1-节点流类型" class="headerlink" title="1.节点流类型"></a>1.节点流类型</h5>该类型可以从或者向一个特定的地点或者节点读写数据。主要类型如下：<br><img src="./节点流.png" alt="IO节点流"><h4 id="2-处理流类型"><a href="#2-处理流类型" class="headerlink" title="2.处理流类型"></a>2.处理流类型</h4>该类型是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写，处理流的构造方法总是要带一个其他流对象作为参数，一个流对象进过其他流的多次包装，叫做流的链接。主要可以分为以下几种：</li></ul><p>(1) 缓冲流（BufferedInPutStream/BufferedOutPutStream和BufferedWriter/BufferedReader）他可以提高对流的操作效率。<br> 写入缓冲区对象：<br> BufferedWriter bufw=new BufferedWriter(new FileWriter(“buf.txt”));<br>读取缓冲区对象：<br> BufferedReader bufr=new BufferedReader(new FileReader(“buf.txt”));<br><code>注意：</code>该类型的流有一个特有的方法：readLine()；一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回，当读到末尾时，返回null，其原理还是与缓冲区关联的流对象的read方法，只不过每一次读取到一个字符，先不进行具体操作，先进行临时储存，当读取到回车标记时，将临时容器中储存的数据一次性返回。</p><p>(2) 转换流（InputStreamReader/OutputStreamWriter）</p><ul><li><p>该类型时字节流和字符流之间的桥梁，该流对象中可以对读取到的字节数据进行指定编码的编码转换。</p><h5 id="构造函数主要有："><a href="#构造函数主要有：" class="headerlink" title="构造函数主要有："></a>构造函数主要有：</h5><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream); <span class="comment">//通过构造函数初始化，使用的是本系统默认的编码表GBK。  </span></span><br><span class="line">InputStreamWriter(InputStream,String charSet);<span class="comment">//通过该构造函数初始化，可以指定编码表。  </span></span><br><span class="line">OutputStreamWriter(OutputStream); <span class="comment">//通过该构造函数初始化，使用的是本系统默认的编码表GBK。  </span></span><br><span class="line">OutputStreamwriter(OutputStream,String charSet); <span class="comment">//通过该构造函数初始化，可以指定编码表。</span></span><br></pre></td></tr></table></figure><p><code>注意：</code>在使用FileReader操作文本数据时，该对象使用的时默认的编码表，即</p><p>FileReader fr=new FileReader(“a.txt”);<br>与   InputStreamReader isr=new InputStreamReader(new FileInputStream(“a.txt”));   的意义相同。如果要使用指定表编码表时，必须使用转换流，即如果a.txt中的文件中的字符数据是通过utf-8的形式编码，那么在读取时，就必须指定编码表，那么转换流时必须的。即：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>),utf-<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>(3) 数据流（<code>DataInputStream/DataOutputStream</code>）</p><ul><li>该数据流可以方便地对一些基本类型数据进行直接的存储和读取，不需要再进一步进行转换，通常只要操作基本数据类型的数据，就需要通过DataStream进行包装。<br>构造方法：        <figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataInputStreamReader（InputStream）；  </span><br><span class="line">DataInputStreamWriter（OutputStream）；</span><br></pre></td></tr></table></figure></li></ul><h5 id="方法举例："><a href="#方法举例：" class="headerlink" title="方法举例："></a>方法举例：</h5><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读取四个字节，并将其转成int值           </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//一次写入四个字节，注意和write(int)不同，write(int)只将该整数的最低一个8位写入，</span></span></span><br><span class="line"><span class="function">剩余三个8为丢失  </span></span><br><span class="line"><span class="function">  <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span>)</span>；</span></span><br><span class="line"><span class="function">  hort <span class="title">readShort</span><span class="params">()</span></span>;  </span><br><span class="line">  writeShort(<span class="keyword">short</span>);</span><br><span class="line"><span class="comment">//按照utf-8修改版读取字符，注意，它只能读writeUTF()写入的字符数据。    </span></span><br><span class="line"> <span class="function">String <span class="title">readUTF</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//按照utf-8修改版将字符数据进行存储，只能通过readUTF读取。</span></span><br><span class="line"> writeUTF(String);</span><br></pre></td></tr></table></figure><p><code>注意：</code>在使用数据流读/存数据的时候，需要有一定的顺序，即某个类型的数据先写入就必须先读出，服从先进先出的原则。</p></li></ul><p>(4) 打印流（PrintStream/PrintWriter）</p><ul><li><code>PrintStream</code>是一个字节打印流，System.out对应的类型就是PrintStream，它的构造函数可以接受三种数据类型的值：字符串路径、File对象 、OutputStream；</li><li><p><code>PrintStream</code>是一个字符打印流，它的构造函数可以接受四种类型的值：字符串路径、File对象、<br>OutputStream；</p><p>(5) 对象流（ObjectInputStream/ObjectOutputStream）</p><p>该类型的流可以把类作为一个整体进行存取，主要方法有：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法抛出异常：ClassNotFountException</span></span><br><span class="line"> <span class="function">Object <span class="title">readObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//被写入的对象必须实现一个接口：Serializable，否则就会抛出：NotSerializableException</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-IO流简单示例-FileInputStream"><a href="#4-IO流简单示例-FileInputStream" class="headerlink" title="4.IO流简单示例(FileInputStream)"></a>4.IO流简单示例(<code>FileInputStream</code>)</h3><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileInputStreamTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis =<span class="keyword">new</span> FileInputStream(<span class="string">"D:/study/iotest/src.txt"</span>);</span><br><span class="line">            fos =<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/study/iotest/dest.txt"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">while</span> ((x = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">              &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="commons-io"><a href="#commons-io" class="headerlink" title="commons-io"></a>commons-io</h1><p>commons-io 是一款处理 io 流的工具，封装了很多处理 io 流和文件的方法，可以大大简化我们处理 io 流和操作文件的代码。从 common-io 的官方使用文档可以看出，它主要分为工具类、尾端类、行迭代器、文件过滤器、文件比较器和扩展流。</p><h3 id="一、工具类"><a href="#一、工具类" class="headerlink" title="一、工具类"></a>一、工具类</h3><h4 id="工具类包括-FileUtils、IOUtils、FilenameUtils和-FileSystemUtils，前三者的方法并没有多大的区别，只是操作的对象不同，故名思议：FileUtils-主要操作-File-类，IOUtils-主要操作-IO-流，FilenameUtils-则是操作文件名，FileSystemUtils-包含了一些-JDK-没有提供的用于访问文件系统的实用方法。当前，只有一个用于读取硬盘空余空间的方法可用。"><a href="#工具类包括-FileUtils、IOUtils、FilenameUtils和-FileSystemUtils，前三者的方法并没有多大的区别，只是操作的对象不同，故名思议：FileUtils-主要操作-File-类，IOUtils-主要操作-IO-流，FilenameUtils-则是操作文件名，FileSystemUtils-包含了一些-JDK-没有提供的用于访问文件系统的实用方法。当前，只有一个用于读取硬盘空余空间的方法可用。" class="headerlink" title="工具类包括 FileUtils、IOUtils、FilenameUtils和 FileSystemUtils，前三者的方法并没有多大的区别，只是操作的对象不同，故名思议：FileUtils 主要操作 File 类，IOUtils 主要操作 IO 流，FilenameUtils 则是操作文件名，FileSystemUtils 包含了一些 JDK 没有提供的用于访问文件系统的实用方法。当前，只有一个用于读取硬盘空余空间的方法可用。"></a>工具类包括 <code>FileUtils、IOUtils、FilenameUtils</code>和 <code>FileSystemUtils</code>，前三者的方法并没有多大的区别，只是操作的对象不同，故名思议：FileUtils 主要操作 File 类，IOUtils 主要操作 IO 流，FilenameUtils 则是操作文件名，FileSystemUtils 包含了一些 JDK 没有提供的用于访问文件系统的实用方法。当前，只有一个用于读取硬盘空余空间的方法可用。</h4><h3 id="二、尾端类"><a href="#二、尾端类" class="headerlink" title="二、尾端类"></a>二、尾端类</h3><h4 id="不同的计算机体系结构使用不同约定的字节排序。在所谓的“低位优先”体系结构中（如-Intel），低位字节处于内存中最低位置，而其后的字节，则处于更高的位置。在“高位优先”的体系结构中（如Motorola），这种情况恰恰相反。"><a href="#不同的计算机体系结构使用不同约定的字节排序。在所谓的“低位优先”体系结构中（如-Intel），低位字节处于内存中最低位置，而其后的字节，则处于更高的位置。在“高位优先”的体系结构中（如Motorola），这种情况恰恰相反。" class="headerlink" title="不同的计算机体系结构使用不同约定的字节排序。在所谓的“低位优先”体系结构中（如 Intel），低位字节处于内存中最低位置，而其后的字节，则处于更高的位置。在“高位优先”的体系结构中（如Motorola），这种情况恰恰相反。"></a>不同的计算机体系结构使用不同约定的字节排序。在所谓的“低位优先”体系结构中（如 <code>Intel</code>），低位字节处于内存中最低位置，而其后的字节，则处于更高的位置。在“高位优先”的体系结构中（如<code>Motorola</code>），这种情况恰恰相反。</h4><ul><li>这个类库上有两个相关类：<br><code>EndianUtils</code>包含用于交换 java 原对象和流之间的字节序列。<br><code>SwappedDataInputStream</code>类是 DataInput 接口的一个实例。使用它，可以读取非本地的字节序列。<h3 id="三、行迭代器"><a href="#三、行迭代器" class="headerlink" title="三、行迭代器"></a>三、行迭代器</h3><h4 id="org-apache-commons-io-LineIterator类提供了一个灵活的方式与基于行的文件交互。可以直接创建一个实例，或者使用-FileUtils-或-IOUtils-的工厂方法来创建，-实例如下："><a href="#org-apache-commons-io-LineIterator类提供了一个灵活的方式与基于行的文件交互。可以直接创建一个实例，或者使用-FileUtils-或-IOUtils-的工厂方法来创建，-实例如下：" class="headerlink" title="org.apache.commons.io.LineIterator类提供了一个灵活的方式与基于行的文件交互。可以直接创建一个实例，或者使用 FileUtils 或 IOUtils 的工厂方法来创建， 实例如下："></a><code>org.apache.commons.io.LineIterator</code>类提供了一个灵活的方式与基于行的文件交互。可以直接创建一个实例，或者使用 FileUtils 或 IOUtils 的工厂方法来创建， 实例如下：</h4><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">    LineIterator li = FileUtils.lineIterator(file);</span><br><span class="line">    <span class="keyword">while</span>(li.hasNext())&#123;</span><br><span class="line">    System.out.println(li.nextLine());</span><br><span class="line">&#125;</span><br><span class="line">LineIterator.closeQuietly(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、文件过滤器"><a href="#四、文件过滤器" class="headerlink" title="四、文件过滤器"></a>四、文件过滤器</h3><h4 id="org-apache-commons-io-filefilter-包定义了一个合并了-java-io-FileFilter-以及-java-io-FilenameFilter-的接口-IOFileFilter-。除此之外，这个包还提供了一系列直接可用的-IOFileFilter-的实现类，可以通过他们合并其它的文件过滤器。比如，这些文件过滤器可以在列出文件时使用或者在使用文件对话框时使用。"><a href="#org-apache-commons-io-filefilter-包定义了一个合并了-java-io-FileFilter-以及-java-io-FilenameFilter-的接口-IOFileFilter-。除此之外，这个包还提供了一系列直接可用的-IOFileFilter-的实现类，可以通过他们合并其它的文件过滤器。比如，这些文件过滤器可以在列出文件时使用或者在使用文件对话框时使用。" class="headerlink" title="org.apache.commons.io.filefilter 包定义了一个合并了 java.io.FileFilter 以及 java.io.FilenameFilter 的接口 (IOFileFilter)。除此之外，这个包还提供了一系列直接可用的 IOFileFilter 的实现类，可以通过他们合并其它的文件过滤器。比如，这些文件过滤器可以在列出文件时使用或者在使用文件对话框时使用。"></a><code>org.apache.commons.io.filefilter</code> 包定义了一个合并了 <code>java.io.FileFilter</code> 以及 <code>java.io.FilenameFilter</code> 的接口 (<code>IOFileFilte</code>r)。除此之外，这个包还提供了一系列直接可用的 <code>IOFileFilter</code> 的实现类，可以通过他们合并其它的文件过滤器。比如，这些文件过滤器可以在列出文件时使用或者在使用文件对话框时使用。</h4><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空内容文件过滤器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmptyFileFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">String[] files = dir.list(EmptyFileFilter.NOT_EMPTY);</span><br><span class="line"><span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名称后缀过滤器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">**<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuffixFileFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">String[] files = dir.list(<span class="keyword">new</span> SuffixFileFilter(<span class="string">"a.txt"</span>));</span><br><span class="line"><span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、文件比较器"><a href="#五、文件比较器" class="headerlink" title="五、文件比较器"></a>五、文件比较器</h3><h4 id="org-apache-commons-io-comparator包为-java-io-File-提供了一些-java-util-Comparator-接口的实现。例如，可以使用这些比较器对文件集合或数组进行排序。-实例如下："><a href="#org-apache-commons-io-comparator包为-java-io-File-提供了一些-java-util-Comparator-接口的实现。例如，可以使用这些比较器对文件集合或数组进行排序。-实例如下：" class="headerlink" title="org.apache.commons.io.comparator包为 java.io.File 提供了一些 java.util.Comparator 接口的实现。例如，可以使用这些比较器对文件集合或数组进行排序。 实例如下："></a><code>org.apache.commons.io.comparator</code>包为 java.io.File 提供了一些 java.util.Comparator 接口的实现。例如，可以使用这些比较器对文件集合或数组进行排序。 实例如下：</h4><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名称比较器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNameFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File f1 = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(basePath + <span class="string">"c.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> result = NameFileComparator.NAME_COMPARATOR.compare(f1, f2);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件路径比较器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPathFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File f1 = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(basePath + <span class="string">"c.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> result = PathFileComparator.PATH_COMPARATOR.compare(f1, f2);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合比较器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">File [] files = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">&#125;</span><br><span class="line">CompositeFileComparator cfc = <span class="keyword">new</span> CompositeFileComparator(</span><br><span class="line">DirectoryFileComparator.DIRECTORY_COMPARATOR,</span><br><span class="line">NameFileComparator.NAME_COMPARATOR);</span><br><span class="line">cfc.sort(files);</span><br><span class="line">System.out.println(<span class="string">"**_**after sort*****"</span>);</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、扩展流"><a href="#六、扩展流" class="headerlink" title="六、扩展流"></a>六、扩展流</h3><h4 id="org-apache-commons-io-input-和-org-apache-commons-io-output包中包含的针对数据流的各种各样的的实现。包括："><a href="#org-apache-commons-io-input-和-org-apache-commons-io-output包中包含的针对数据流的各种各样的的实现。包括：" class="headerlink" title="org.apache.commons.io.input 和 org.apache.commons.io.output包中包含的针对数据流的各种各样的的实现。包括："></a><code>org.apache.commons.io.input</code> 和 <code>org.apache.commons.io.output</code>包中包含的针对数据流的各种各样的的实现。包括：</h4><ul><li>空输出流－默默吸收发送给它的所有数据</li><li>T 型输出流－全用两个输出流替换一个进行发送</li><li>字节数组输出流－这是一个更快版本的 JDK 类</li><li>计数流－计算通过的字节数</li><li>代理流－使用正确的方法委拖</li><li>可锁写入－使用上锁文件提供同步写入</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="IO流" scheme="http://yoursite.com/tags/IO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring 4.x Task 和 Schedule</title>
    <link href="http://yoursite.com/2019/06/01/Spring%20Task%20%E5%92%8C%20Schedule/"/>
    <id>http://yoursite.com/2019/06/01/Spring Task 和 Schedule/</id>
    <published>2019-05-31T18:42:17.623Z</published>
    <updated>2019-05-31T18:45:09.697Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 4.x Task 和 Schedule</p><p>在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素<br>之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容：</p><p>Java 对异步执行和任务调度的支持<br>Spring 4.X 的异步执行和任务调度实现<br>Java 对异步执行和任务调度的支持</p><p>异步执行和任务调度底层的语言支撑都是Java 的多线程技术。线程是系统进行独立运行和调度的基本单位。拥有了多线程，系统就拥有了同时处理多项任务的能力。</p><p>Java 实现异步调用</p><p>在Java 中要实现多线程有实现Runnable 接口和扩展Thread 类两种方式。只要将需要异步执行的任务放在run() 方法中，在主线程中启动要执行任务的子线程就可以实现任务的异步执行。如果需要实现基于<br>时间点触发的任务调度，就需要在子线程中循环的检查系统当前的时间跟触发条件是否一致，然后触发任务的执行。该内容属于Java 多线程的基础知识，此处略过不讲。</p><p>Java Timer 和 TimeTask 实现任务调度</p><p>为了便于开发者快速地实现任务调度，Java JDK 对任务调度的功能进行了封装，实现了Timer 和TimerTask 两个工具类。</p><p>TimerTask 类</p><p>由上图，我们可以看出TimeTask 抽象类在实现Runnable 接口的基础上增加了任务cancel() 和任务scheduledExecuttionTime() 两个方法。</p><p>Timer 类</p><p>上图为调度类Timer 的实现。从Timer类的源码，可以看到其采用TaskQueue 来实现对多个TimeTask 的管理。TimerThread 集成自Thread 类，其mainLoop() 用来对任务进行调度。而Timer 类提供了四种重载<br>的schedule() 方法和重载了两种sheduleAtFixedRate() 方法来实现几种基本的任务调度类型。下面的代码是采用Timer 实现的定时系统时间打印程序。</p><p>public class PrintTimeTask extends TimerTask {<br>    @Override<br>        public void run() {<br>            System.out.println(new Date().toString());<br>        }</p><pre><code>public static void main(String[] args) {    Timer timer = new Timer(&quot;hello&quot;);    timer.schedule(new PrintTimeTask(), 1000L, 2000L);}</code></pre><p>}</p><p>Spring 4.x 中的异步执行和任务调度</p><p>Spring 4.x 中的异步执行</p><p>Spring 作为一站式框架，为开发者提供了异步执行和任务调度的抽象接口TaskExecutor 和TaskScheduler。Spring 对这些接口的实现类支持线程池(Thread Pool) 和代理。<br>Spring 提供了对JDK 中Timer和开源的流行任务调度框架Quartz的支持。Spring 通过将关联的Schedule 转化为FactoryBean 来实现。通过Spring 调度框架，开发者可以快速地通过MethodInvokingFactoryBean<br>来实现将POJO 类的方法转化为任务。</p><p>Spring TaskExecutor</p><p>TaskExecutor 接口扩展自java.util.concurrent.Executor 接口。TaskExecutor 被创建来为其他组件提供线程池调用的抽象。</p><p>ThreadPoolTaskExecutor 是TaskExecutor 的最主要实现类之一。该类的核心继承关系如下图所示。<br>ThreadPooltaskexecutor 类</p><p>ThreadPoolTaskExecutor 接口扩展了重多的接口，让其具备了更多的能力。要实现异步需要标注@Async 注解：</p><p>AsyncTaskExecutor 增加了返回结果为Future 的submit() 方法，该方法的参数为Callable 接口。相比Runnable 接口，多了将执行结果返回的功能。<br>AsyncListenableTaskExecutor 接口允许返回拥有回调功能的ListenableFuture 接口，这样在结果执行完毕是，能够直接回调处理。<br>public class ListenableTask {<br>    @Async<br>    public ListenableFuture<integer> compute(int n) {<br>        int sum = 0;<br>        for (int i = 0; i &lt; n; i++) {<br>            sum += i;<br>        }<br>        return new AsyncResult&lt;&gt;(sum);<br>    }</integer></p><pre><code>static class CallBackImpl implements     ListenableFutureCallback&lt;Integer&gt; {    @Override    public void onFailure(Throwable ex) {        System.out.println(ex.getMessage());    }    @Override    public void onSuccess(Integer result) {        System.out.println(result);    }}public static void main(String[] args) {    ListenableTask listenableTask = new ListenableTask();    ListenableFuture&lt;Integer&gt; listenableFuture =         listenableTask.compute(10);    listenableFuture.addCallback(new CallBackImpl());}</code></pre><p>}</p><p>ThreadFactory 定义了创建线程的工厂方法，可以扩展该方法实现对Thread 的改造。<br>基于Java Config</p><p>基于注解 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableAsync 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。<br>@Configuration<br>@EnableAsync<br>public class AppConfig {<br>}<br>1<br>2<br>3<br>4<br>基于AsyncConfigurer接口自定义 开发者可以自定义Executor 的类型，并且注册异常处理器。<br>@Configuration<br>public class TaskConfig implements AsyncConfigurer {<br>    @Override<br>    public Executor getAsyncExecutor() {<br>        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br>        executor.setMaxPoolSize(100);<br>        executor.setCorePoolSize(10);<br>        return executor;<br>    }</p><pre><code>@Overridepublic AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {    return new AsyncUncaughtExceptionHandler() {        @Override        public void handleUncaughtException(Throwable ex,                                             Method method, Object... params) {            System.out.println(ex.getMessage());        }    };}</code></pre><p>}</p><p>基于XML Config</p><p>基于传统XML的配置 基于XML 的形式，采用传统的Java Bean的形式配置ThreadPoolTaskExecutor。然后采用自动注入(autowire, resource,name)的可以直接在Spring Component 中注入Executor。<br>以编程的形式实现异步任务。</p><p><bean id="taskExecutor" class="org.springframework.scheduling.concurrent.    ThreadPoolTaskExecutor"><br>    <property name="corePoolSize" value="5"><br>    <property name="maxPoolSize" value="10"><br>    <property name="queueCapacity" value="25"><br></property></property></property></bean><br>1<br>2<br>3<br>4<br>5<br>6<br>基于task 命名空间的配置 Spring 为任务的执行提供了便利的task 命名空间。当采用基于XML 配置时Spring 会自动地为开发者创建Executor。同时可以在annotation-driven 标签上注册<br>实现了AsyncUncaughtExceptionHandler 接口的异常处理器。<br><!-- config exception handler  --></p><p><bean id="taskAsyncExceptionHandler" class="org.zzy.spring4.application.schedulie.TaskAsyncExceptionHandler"><br>&lt;task:annotation-driven exception-handler=”taskAsyncExceptionHandler” scheduler=”scheduler” executor=”executor”/&gt;<br>1<br>2<br>3<br>异步执行的异常处理</bean></p><p>除了上文提到的两种异常处理方式，Spring 还提供了基于SimpleApplicationEventMulticaster 类的异常处理方式。</p><p>@Bean<br>public SimpleApplicationEventMulticaster eventMulticaster(TaskExecutor taskExecutor) {<br>    SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster();<br>    eventMulticaster.setTaskExecutor(taskExecutor);<br>    eventMulticaster.setErrorHandler(new ErrorHandler() {<br>        @Override<br>        public void handleError(Throwable t) {<br>            System.out.println(t.getMessage());<br>        }<br>    });<br>    return eventMulticaster;<br>}</p><p>Spring 4.x 中任务调度实现</p><p>Spring 的任务调度主要基于TaskScheduler 接口。ThreadPoolTaskScheduler 是Spring 任务调度的核心实现类。该类提供了大量的重载方法进行任务调度。Trigger 定义了任务被执行的触发条件。<br>Spring 提供了基于Corn 表达式的CornTrigger实现。TaskScheduler 如下图所示。<br>ThreadPoolTaskExecutor 类</p><p>实现TaskScheduler 接口的ThreadPoolTaskExecutor 继承关系。<br>ThreadPoolTaskExecutor 类</p><p>基于Java Config</p><p>基于注解的配置 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableScheduling 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。<br>@Configuration<br>@EnableScheduling<br>public class AppConfig {<br>}<br>1<br>2<br>3<br>4<br>基于SchedulingConfigurer接口自定义<br>@Configuration<br>public class ScheduleConfig implements SchedulingConfigurer {<br>    @Override<br>    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {<br>        taskRegistrar.setTaskScheduler(new ThreadPoolTaskScheduler());<br>        taskRegistrar.getScheduler().schedule(new Runnable() {<br>            @Override<br>            public void run() {<br>                System.out.println(“hello”);<br>            }<br>        }, new CronTrigger(“0 15 9-17 <em> </em> MON-FRI”));<br>    }<br>}</p><p>基于XML Config</p><p>&lt;task:annotation-driven scheduler=”myScheduler”/&gt;<br>&lt;task:scheduler id=”myScheduler” pool-size=”10”/&gt;<br>1<br>2<br>@Scheduled 注解的使用</p><p>当某个Bean 由Spring 管理生命周期时，就可以方便的使用@Shcheduled 注解将该Bean 的方法准换为基于任务调度的策略。</p><p>@Scheduled(initialDelay=1000, fixedRate=5000)<br>public void doSomething() {<br>    // something that should execute periodically<br>}</p><p>@Scheduled(cron=”<em>/5 </em> <em> </em> * MON-FRI”)<br>public void doSomething() {<br>    // something that should execute on weekdays only<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>task 命名空间中的task:scheduled-tasks</p><p>该元素能够实现快速地将一个普通Bean 的方法转换为Scheduled 任务的途径。具体如下：</p><p>&lt;task:scheduled-tasks scheduler=”myScheduler”&gt;<br>    &lt;task:scheduled ref=”beanA” method=”methodA” fixed-delay=”5000” initial-delay=”1000”/&gt;<br>    &lt;task:scheduled ref=”beanB” method=”methodB” fixed-rate=”5000”/&gt;<br>    &lt;task:scheduled ref=”beanC” method=”methodC” cron=”<em>/5 </em> <em> </em> * MON-FRI”/&gt;<br>&lt;/task:scheduled-tasks&gt;<br>&lt;task:scheduler id=”myScheduler” pool-size=”10”/&gt;</p><p>总结</p><p>本文着重介绍了JDK 为任务调度提供的基础类Timer。并在此基础上详细介绍了Spring 4.x 的异步执行和任务调度的底层接口设计。并针对常用的模式进行了讲解，并附带了源代码。<br>第三方开源的Quartz 实现了更为强大的任务调度系统，Spring 也对集成Quartz 提供了转换。之后会择机再详细的介绍Quartz 的应用和设计原理。同时，Servlet 3.x 为Web 的异步<br>调用提供了AsyncContext，对基于Web 的异步调用提供了原生的支持，后续的文章也会对此有相应的介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring 4.x Task 和 Schedule&lt;/p&gt;
&lt;p&gt;在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素&lt;br&gt;之一。因此在We
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Resource</title>
    <link href="http://yoursite.com/2019/06/01/Spring%20Resource/"/>
    <id>http://yoursite.com/2019/06/01/Spring Resource/</id>
    <published>2019-05-31T18:42:15.521Z</published>
    <updated>2019-05-31T18:44:12.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Resource"><a href="#Spring-Resource" class="headerlink" title="Spring Resource"></a>Spring Resource</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    在日常程序开发中，处理外部资源是很繁琐的事情，我们可能需要处理URL资源、File资源资源、<code>ClassPath</code>相关资源、服务器相关资源（JBoss AS 5.x上的VFS资源）等等很多资源。因此处理这些资源需要使用不同的接口，这就增加了我们系统的复杂性；而且处理这些资源步骤都是类似的（打开资源、读取资源、关闭资源），因此如果能抽象出一个统一的接口来对这些底层资源进行统一访问，是不是很方便，而且使我们系统更加简洁，都是对不同的底层资源使用同一个接口进行访问。</p><p>​       Spring 提供一个Resource接口来统一这些底层资源一致的访问，而且提供了一些便利的接口，从而能提供我们的生产力。</p><h3 id="Resource-接口"><a href="#Resource-接口" class="headerlink" title="Resource 接口"></a>Resource 接口</h3><ul><li><p>Spring的Resource接口代表底层外部资源，提供了对底层外部资源的一致性访问接口。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;  </span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>InputStreamSource接口解析</p><ul><li><strong>getInputStream</strong>：每次调用都将返回一个新鲜的资源对应的<code>java.io. InputStream</code>字节流，调用者在使用完毕后必须关闭该资源。</li><li>Resource接口继承<code>InputStreamSource</code>接口，并提供一些便利方法：<ul><li><strong>exists</strong>：返回当前Resource代表的底层资源是否存在，true表示存在。</li><li><strong>isReadable</strong>：返回当前Resource代表的底层资源是否可读，true表示可读。</li><li><strong>isOpen</strong>：返回当前Resource代表的底层资源是否已经打开，如果返回true，则只能被读取一次然后关闭以避免资源泄露；常见的Resource实现一般返回false。</li><li><strong>getURL</strong>：如果当前Resource代表的底层资源能由java.util.URL代表，则返回该URL，否则抛出IOException。</li><li><strong>getURI</strong>：如果当前Resource代表的底层资源能由java.util.URI代表，则返回该URI，否则抛出IOException。</li><li><strong>getFile</strong>：如果当前Resource代表的底层资源能由java.io.File代表，则返回该File，否则抛出IOException。</li><li><strong>contentLength</strong>：返回当前Resource代表的底层文件资源的长度，一般是值代表的文件资源的长度。</li><li><strong>lastModified</strong>：返回当前Resource代表的底层资源的最后修改时间。</li><li><strong>createRelative</strong>：用于创建相对于当前Resource代表的底层资源的资源，比如当前Resource代表文件资源“d:/test/”则createRelative（“test.txt”）将返回表文件资源“d:/test/test.txt”Resource资源。</li><li><strong>getFilename</strong>：返回当前Resource代表的底层文件资源的文件路径，比如File资源“file://d:/test.txt”将返回“d:/test.txt”，而URL资源<a href="http://www.javass.cn将返回“”，因为只返回文件路径。" target="_blank" rel="noopener">http://www.javass.cn将返回“”，因为只返回文件路径。</a></li><li><strong>getDescription</strong>：返回当前Resource代表的底层资源的描述符，通常就是资源的全路径（实际文件名或实际URL地址）。    </li></ul></li><li>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：<code>ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource</code>等。</li></ul><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;  </span><br><span class="line">       <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">       <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">       <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">       <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">       <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">       <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">       <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;  </span><br><span class="line">       <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Resource 和 @Autowired的不同</p><ul><li><p>@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。</p></li><li><p>@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：<br>@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>() <span class="meta">@Qualifier</span>(<span class="string">"baseDao"</span>)    </span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure></li><li><p>@Resource 是JDK1.6支持的注解<strong>，</strong>默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名，按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。只不过注解处理器我们使用的是Spring提供的，是一样的，无所谓解耦不解耦的说法，两个在便利程度上是等同的。</p></li><li><p>他们的主要区别就是@Autowired是默认按照类型装配的 @Resource默认是按照名称装配的<br>byName 通过参数名 自动装配，如果一个bean的name 和另外一个bean的 property 相同，就自动装配。<br>byType 通过参数的数据类型自动自动装配，如果一个bean的数据类型和另外一个bean的property属性的数据类型兼容，就自动装配</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"baseDao"</span>)    </span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure></li><li><p>我们可以通过 @Autowired 或 @Resource 在 Bean 类中使用自动注入功能，但是 Bean 还是在 XML 文件中通过 <bean> 进行定义 —— 也就是说，在 XML 配置文件中定义 Bean，通过@Autowired 或 @Resource 为 Bean 的成员变量、方法入参或构造函数入参提供自动注入的功能。<br>比如下面的beans.xml。</bean></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">private</span> Office office;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略 get/setter</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"car:"</span> + car + <span class="string">"\n"</span> + <span class="string">"office:"</span> + office;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boss"</span> <span class="attr">class</span>=<span class="string">"com.wuxinliulei.Boss"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"office"</span> <span class="attr">class</span>=<span class="string">"com.wuxinliulei.Office"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"officeNo"</span> <span class="attr">value</span>=<span class="string">"001"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.wuxinliulei.Car"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">" 红旗 CA72"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"2000"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>​</p></li><li><p>定义了三个bean对象，但是没有了我们书序的ref指向的内容<br>比如</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string"> http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boss"</span> <span class="attr">class</span>=<span class="string">"com.wuxinliulei.Boss"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"office"</span> <span class="attr">ref</span>=<span class="string">"office"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"office"</span> <span class="attr">class</span>=<span class="string">"com.wuxinliulei.Office"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"officeNo"</span> <span class="attr">value</span>=<span class="string">"002"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.wuxinliulei.Car"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">" 红旗 CA72"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"2000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>spring2.5提供了基于注解（Annotation-based）的配置，我们可以通过注解的方式来完成注入依赖。在Java代码中可以使用 @Resource或者@Autowired注解方式来经行注入。虽然@Resource和@Autowired都可以来完成注入依赖，但它们之间是有区 别的。首先来看一下：</p><ul><li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入</li><li>@Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier一起使用</li><li>@Resource注解是由JDK提供，而@Autowired是由Spring提供</li><li>@Resource和@Autowired都可以书写标注在字段或者该字段的setter方法之上。  </li></ul></li><li><p>使用注解的方式，我们需要修改spring配置文件的头信息如下:</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"Index of /schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"Index of /schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">Index of /schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span></span><br><span class="line">               </span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Resource&quot;&gt;&lt;a href=&quot;#Spring-Resource&quot; class=&quot;headerlink&quot; title=&quot;Spring Resource&quot;&gt;&lt;/a&gt;Spring Resource&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/06/01/%E5%9F%BA%E7%A1%80%E7%A0%94%E5%8F%91%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2019/06/01/基础研发能力提升/</id>
    <published>2019-05-31T18:42:03.682Z</published>
    <updated>2019-05-13T09:56:54.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础研发能力提升总结"><a href="#基础研发能力提升总结" class="headerlink" title="基础研发能力提升总结"></a>基础研发能力提升总结</h1><p>下周就是元旦节了，转眼2017年也要过去了。不知道各位小伙伴2017年的计划完成了多少，得到了什么，又失去了什么。<br>今年研发中心大力推行<code>基础研发能力提升</code>，刚开始推进的时候，其实我内心是拒绝的。学习是自己的事，居然还得自上而下“逼”大家来学，学习这件事应该是自下而上，自发组织才是。我不能理解居然有不愿意学习的研发人员。<br><strong>不重视基础研发能力，而想做出精品软件，可乎？其本乱而末治者，否矣。</strong><br>吴军老师在他的得到专栏中提到“做事情的三条边”。<br><img src="images/做好事情的三条边.jpg" alt="做好事情的三条边"><br><strong>下面一条线是基础，也就是基线。</strong>上面一条线就是极限，中间就是从基线到极限的通道。我们做的基础研发能力提升，就是不断提高大家的基线。基础研发能力提升也没有尽头，也许今天我们的极限就是明天的基线。知行合一，止于至善。</p><h2 id="基础研发能力提升的成果"><a href="#基础研发能力提升的成果" class="headerlink" title="基础研发能力提升的成果"></a>基础研发能力提升的成果</h2><p>在过去的一年，有理想、有追求的程序员、业务人员都已经参与到基础研发能力提升中了。在MVD中，有着开源精神的IT人们，贡献了以下这些宝贵的资料：</p><ul><li>标准规范文档 - <strong>76份</strong></li><li>代码整洁规范 - <strong>10份</strong></li><li>好代码坏代码总结 - <strong>50份</strong></li><li>commons &amp; java基础类库培训文档 - <strong>71份</strong>  </li><li>需求和业务文档 - <strong>3000余份</strong> </li><li>生产环境疑难问题总结 - <strong>25份</strong></li></ul><p>在这里尤其感谢陈家银，郭锋，王冰，黄美媛等人的总结，每一份文档都能感受到作者做为一个IT人的精神：务真、求实、分享。</p><h2 id="老码农们的建议"><a href="#老码农们的建议" class="headerlink" title="老码农们的建议"></a>老码农们的建议</h2><p>往者不可谏，来者犹可追。以下是几个老码农给新码农的一些建议，希望对你们有所用。</p><h3 id="增强知识的深度"><a href="#增强知识的深度" class="headerlink" title="增强知识的深度"></a>增强知识的深度</h3><p>在学习时，要做到刨根问底，不仅知其然，也知其所以然。不要花太多精力放在记忆性的内容上。如果不在实战中运用用，记住了也很快就会忘。</p><h3 id="增强知识的广度"><a href="#增强知识的广度" class="headerlink" title="增强知识的广度"></a>增强知识的广度</h3><p>IT行业从没如此繁荣，也会继续在这可见的一二十年中继续繁荣。新的技术层不出穷，出来一个热门的新技术，你还没来得学，这个技术就已经被淘汰了。对于新技术的趋势，要有所了解，持续关注。</p><h3 id="不要埋头写代码"><a href="#不要埋头写代码" class="headerlink" title="不要埋头写代码"></a>不要埋头写代码</h3><p>写代码只是手段，不是目的。不要以为编码就是王道，什么产品规划、需求业务，市场推广，那都不叫事。 咱们扪心自问，加那么多班，熬那么多夜，最后我们有多少拿的出手的成果，有多少是在重复造轮子。无论是做产品还是做开源，只有用的人觉得好了，这个代码才是有意义的，而要做好这些，程序员既要能埋头写代码，又要能对需求、业务，市场动态有所了解。</p><h3 id="知行合一，止于至善"><a href="#知行合一，止于至善" class="headerlink" title="知行合一，止于至善"></a>知行合一，止于至善</h3><p>Linus Torvalds说<code>Talk is cheap. Show me the code</code>。有些同学会hello world就敢说精通，听过名字就敢说熟练使用。每一次你说精通，可能都表示你看到的天只有井底的那一小片，所以你会说我已经看到整片天了。知不弃行，行不离思，慎思之，笃行之。知和行是相辅相成，不断升华。</p><h3 id="多做笔记，勤总结"><a href="#多做笔记，勤总结" class="headerlink" title="多做笔记，勤总结"></a>多做笔记，勤总结</h3><p>多做笔记，要学的东西太多，学不过来，也记不过来。把重要的内容分类做好笔记，用到时方便找到。<br>子曰：学而不思则罔 思而不学则殆。多做总结，一是可以让知识学得更扎实，二是让自己不要总是犯同样的错误。</p><h3 id="努力努力努力"><a href="#努力努力努力" class="headerlink" title="努力努力努力"></a>努力努力努力</h3><p>让自己成为一个更好的自己。新来的学妹都喜欢努力的男生。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望2018年不再需要自上而下来“逼”大家学，每个项目组都会自发的制定学习计划，也有人自发组织兴趣小组。<br>新的一年，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础研发能力提升总结&quot;&gt;&lt;a href=&quot;#基础研发能力提升总结&quot; class=&quot;headerlink&quot; title=&quot;基础研发能力提升总结&quot;&gt;&lt;/a&gt;基础研发能力提升总结&lt;/h1&gt;&lt;p&gt;下周就是元旦节了，转眼2017年也要过去了。不知道各位小伙伴2017年的计划
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码复查方法总结</title>
    <link href="http://yoursite.com/2019/06/01/%E4%BB%A3%E7%A0%81%E5%A4%8D%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/01/代码复查方法总结/</id>
    <published>2019-05-31T18:40:16.858Z</published>
    <updated>2019-05-31T18:40:57.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码复查方法总结"><a href="#代码复查方法总结" class="headerlink" title="代码复查方法总结"></a>代码复查方法总结</h1><h2 id="一、人工复查忽略工具可以复查的问题"><a href="#一、人工复查忽略工具可以复查的问题" class="headerlink" title="一、人工复查忽略工具可以复查的问题"></a>一、人工复查忽略工具可以复查的问题</h2><p>代码复查需要带着目标来查，人工复查不要过分关注可以采用自动化工具可以复查的部分，例如通过findbugs和checkstyle可以扫描出来的问题（当然复查人或者研发经理需要关注和推动findbugs问题和checkstyle问题的持续改进）。其中工具可以复查的问题总结如下：</p><blockquote><ul><li>Dead store to local variable 本地变量存储了闲置不用的对象</li><li>Load of known null value 可能会出现空指针异常</li><li>Exception is caught when Exception is not thrown 捕获了异常但是try里并没有抛出异常</li><li>Method ignores exceptional return value 没有对方法的异常返回值进行检查</li><li>Comparison of String objects using == or !=</li><li>Method names should start with a lower case letter</li><li>Non-transient non-serializable instance field in serializable class</li><li>诸多格式问题</li><li><a href="http://blog.csdn.net/aya19880214/article/details/42551903" target="_blank" rel="noopener">more</a></li></ul></blockquote><h2 id="二、重点关注典型问题"><a href="#二、重点关注典型问题" class="headerlink" title="二、重点关注典型问题"></a>二、重点关注典型问题</h2><p>典型问题是基于公司业务场景和类型总结出来的容易出现的代码问题，复查的时候可以有针对性的查找这方面问题</p><blockquote><ul><li><ol><li>Artery项目中，使用列表的行脚本、控件的onfilter脚本、控件的onshow脚本时，编写查询或更新数据库的脚本，使得每刷新一个相关页面，产生大量SQL，从而导致性能问题</li></ol></li><li><ol start="2"><li>在循环中（for、wihle），存在查询或更新数据库的脚本，将导致产生大量SQL的问题</li></ol></li><li><ol start="3"><li>在循环中（for、wihle），存在查询或更新数据库的脚本，且没有对垃圾数据进行处理，导致无限循环或一个跨度较大的循环，将导致产生大量SQL的问题</li></ol></li><li><ol start="4"><li>在一次业务处理中，反复从数据库装载同一对象，将导致产生重复大量SQL的问题</li></ol></li><li><ol start="5"><li>SQL脚本操作一批数据，是通过in来实现的，没有预估到in的个数量，导致拼接的SQL很长</li></ol></li><li><ol start="6"><li>文件处理，没有考虑到大文件，一次性申请大量的内存进行文件处理，导致内存溢出</li></ol></li><li><ol start="7"><li>SQL查询中，不能使用select * 进行查询</li></ol></li><li><ol start="8"><li>SQL查询时，条件语句中带or的话，很容易造成全表扫描。最好不要出现这样的sql，可以使用in、union、uion all 代替</li></ol></li><li><ol start="9"><li>异常处理中，捕获异常后，没有使用日志框架记录日志的。</li></ol></li><li><ol start="10"><li>sql查询数据量的时候，使用select查询明细，然后再通过Collection.getSize()获取数据量，会导致查询效率地下。要使用select count的方式</li></ol></li><li><ol start="11"><li>接口返回批量数据的时候，必须做分页控制。避免一次返回上万条数据，效率低而且容易导致JVM内存溢出</li></ol></li></ul></blockquote><h2 id="三、跟踪并总结常见问题"><a href="#三、跟踪并总结常见问题" class="headerlink" title="三、跟踪并总结常见问题"></a>三、跟踪并总结常见问题</h2><h3 id="集合使用问题"><a href="#集合使用问题" class="headerlink" title="集合使用问题"></a>集合使用问题</h3><blockquote><ul><li>1.List的遍历，代码中要使用迭代器(foreach)而不是index</li><li>2.List集合选择，如果能预知集合大小，在初始化集合的时候应该设置集合大小，避免ArrayList动态扩容。如果无法预知集合大小，建议采用LinkedList</li><li>3.LinkedList禁止使用XXX.get(i)</li><li>4.Map遍历禁止使用keySet遍历，在循环体中用XXXMap.get(key)获取value，要使用entrySet进行遍历</li></ul></blockquote><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><blockquote><ul><li><ol><li>关注spring bean中定义属性变量，关注Utils类中的静态变量的实例化伙计</li></ol></li><li><ol start="2"><li>关注缓存类的init，reload，get方法间的并发可能性</li></ol></li><li><ol start="3"><li>重点关注程序中出现new Thread，Executors的地方对创建线程，或者线程池的使用</li></ol></li></ul></blockquote><h3 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h3><blockquote><ul><li><ol><li>关注每次访问redis都重新创建和关闭连接，需要使用jedis连接池</li></ol></li><li><ol start="2"><li>关注程序是否一次从redis上下载大量数据</li></ol></li><li><ol start="3"><li>关注在for循环中操作redis</li></ol></li></ul></blockquote><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><blockquote><ul><li><ol><li>关注日志记录中是否合理使用了error、warn、info、debug等日志级别</li></ol></li><li><ol start="2"><li>关注日志的输出是否可以支撑后续问题排查和生成环境调试需求，需要输出的信息是否完整输出</li></ol></li></ul></blockquote><h3 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h3><blockquote><ul><li><ol><li>关注正常、异常情况下流是否能正常关闭</li></ol></li></ul></blockquote><p>### </p><h2 id="四、类设计复查"><a href="#四、类设计复查" class="headerlink" title="四、类设计复查"></a>四、类设计复查</h2><blockquote><ul><li>关注类的实现是否符合单一职责原则，重点关注超过500行代码的实现类</li><li>关注代码的依赖是否需要遵循依赖倒置原则（根据业务需求是否会频繁变化作为判断依据）</li><li>关注代码的时候是否符合迪米特法则，重点复查多个类质检是否有A依赖B，同时B也依赖A的情况</li><li>关注接口或类方法中是否返回了List或者Map这样的数据（一个类可以依赖另一个类去实现一个业务逻辑，但是要避免依赖另一个类的数据结构）</li></ul></blockquote><h2 id="五、公司规范复查"><a href="#五、公司规范复查" class="headerlink" title="五、公司规范复查"></a>五、公司规范复查</h2><p>公司的技术规范规定了很多设计和开发方面的约束，有时候架构师或者设计人员对规范中已经规定了的部分在设计的时候可能不再赘述，代码复查的时候也要关注这部分规范的执行情况</p><blockquote><ul><li>1.增量设计（《数据增量设计说明书.docx》）实现，表结构中设计的增量字段在编码的时候是否考虑更新这些字段的值</li><li>2.接口规范（《Q3-DEV-04-02-接口文档模板.doc》）的实现，代码复查的时候关注实现的接口是否按照改文档定义的接口结构组装数据，是否按照文档中规定的状态代码返回。</li></ul></blockquote><h2 id="六、工具、框架复用类复查"><a href="#六、工具、框架复用类复查" class="headerlink" title="六、工具、框架复用类复查"></a>六、工具、框架复用类复查</h2><p>代码复查的时候要关注代码中是否可以复用某些类库或公司的组件实现，避免重复劳动。即使已经实现，也应该通过代码复查的方式告诉对应编码人员有工具可以复用；重点关注commons-lang、commons-io和ArteryXXXUtils以及commons-thunisoft包中的工具类的复用。</p><h2 id="七、业务逻辑复查"><a href="#七、业务逻辑复查" class="headerlink" title="七、业务逻辑复查"></a>七、业务逻辑复查</h2><p>没有彩蛋，对于核心模块，需要先熟悉业务逻辑，再根据业务逻辑走查代码，判断代码实现逻辑是否和预期一致。</p><h2 id="八、安全问题复查"><a href="#八、安全问题复查" class="headerlink" title="八、安全问题复查"></a>八、安全问题复查</h2><p>如果是互联网或者和别的公司的对接项目，还需要对接口、系统页面的安全性进行复查。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码复查方法总结&quot;&gt;&lt;a href=&quot;#代码复查方法总结&quot; class=&quot;headerlink&quot; title=&quot;代码复查方法总结&quot;&gt;&lt;/a&gt;代码复查方法总结&lt;/h1&gt;&lt;h2 id=&quot;一、人工复查忽略工具可以复查的问题&quot;&gt;&lt;a href=&quot;#一、人工复查忽略工具可以
      
    
    </summary>
    
      <category term="Java代码之美" scheme="http://yoursite.com/categories/Java%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Google Java编程风格指南</title>
    <link href="http://yoursite.com/2019/06/01/Google%20Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/06/01/Google Java编程风格指南/</id>
    <published>2019-05-31T18:39:09.335Z</published>
    <updated>2019-05-31T18:39:52.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-Java编程风格指南"><a href="#Google-Java编程风格指南" class="headerlink" title="Google Java编程风格指南"></a>Google Java编程风格指南</h1><p>标签： Java<br>原文地址: <a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是<code>Google Java</code>编程风格规范的完整定义。当且仅当一个<code>Java</code>源文件符合此文档中的规则，我们才认为它符合<code>Google</code>的<code>Java</code>编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语<code>class</code>可表示一个普通类、枚举类、接口或者注解。</li><li>术语<code>comment</code>只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用<code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用<code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code>水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code>字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>任何需要转义字符串表示的字符（例如：<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\\</code>等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 <code>\012</code>）或<code>Unicode</code>码（例如：<code>\u000a</code>）表示。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于其余非<code>ASCII</code>字符，直接使用<code>Unicode</code>字符（例如 <code>∞</code>），或者使用对应的<code>Unicode</code>码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用<code>Unicode</code>字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非<code>ASCII</code>字符而让你的代码可读性变差。当程序无法正确处理非<code>ASCII</code>字符时，它自然无法正确运行，你就会去<code>fix</code>这些问题的了。(言下之意就是大胆去用非<code>ASCII</code>字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code>语句</li><li><code>import</code>语句</li><li><code>class</code>类声明（每个源码文件只能有唯一一个顶级<code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间应该只有<strong>一个空行</strong>作为间隔。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不使用通配符"><a href="#3-3-1-import不使用通配符" class="headerlink" title="3.3.1 import不使用通配符"></a>3.3.1 import不使用通配符</h4><p><code>import</code>语句中不应该使用通配符，不管是否是静态导入。</p><h4 id="3-3-2-import不换行"><a href="#3-3-2-import不换行" class="headerlink" title="3.3.2 import不换行"></a>3.3.2 import不换行</h4><p><code>import</code>语句不换行，列限制(4.4节)并不适用于<code>import</code>语句。(每个<code>import</code>语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code>语句可分为以下几组，按照顺序，每组由<strong>一个空行</strong>分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code>包的<code>import</code>归为一组</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li><li><code>java</code>包归为一组</li><li><code>javax</code>包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的<code>import</code>语句之间不应用空行隔开，同一组中的<code>import</code>语句按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级class"><a href="#3-4-1-只声明唯一一个顶级class" class="headerlink" title="3.4.1 只声明唯一一个顶级class"></a>3.4.1 只声明唯一一个顶级class</h4><p>每个源文件中只能有一个顶级class。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用K-amp-R风格"><a href="#4-1-2-非空语句块采用K-amp-R风格" class="headerlink" title="4.1.2 非空语句块采用K&amp;R风格"></a>4.1.2 非空语句块采用<code>K&amp;R</code>风格</h4><p>对于非空语句块，大括号遵循<code>Kernighan</code>和<code>Ritchie</code>风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接<code>else</code>或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (condition()) &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                something();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">                recover();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherCondition()) &#123;</span><br><span class="line">            somethingElse();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastThing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：<code>if/else</code> 或者<code>try/catch/finally</code>）.</p><p>示例：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是可接受的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这同样是可接受的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是不可接受的：多块语句中没有简洁的空语句块</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为<code>100个</code>字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到shell中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code>个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。</li><li>如果要在非赋值运算符处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code>表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLambda&lt;String, Long, Object&gt; lambda =</span><br><span class="line">    (String label, Long value, Object obj) -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; predicate = str -&gt;</span><br><span class="line">    longExpressionInvolving(str);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进<code>4</code>个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只<code>4</code>个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code>语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code>等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：<code>a = 0; // 赋值为0</code>）</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。（例如：<code>List&lt;String&gt; list</code>）</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>）</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x;   <span class="comment">// 这种挺好</span></span><br><span class="line"><span class="keyword">private</span> Color color;   <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// 允许，但是未来会继续编辑</span></span><br><span class="line"><span class="keyword">private</span> Color color;  <span class="comment">// 可能会使它对不齐</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和<code>reviewer</code>都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Answer &#123;</span><br><span class="line">    YES &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    NO,</span><br><span class="line">    MAYBE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有方法和Javadoc的枚举类可写成数组初始化的格式：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;           <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>            <span class="number">0</span>,</span><br><span class="line">&#125;                       <span class="number">1</span>,</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;             <span class="number">3</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,               &#125;</span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;                     <span class="keyword">new</span> <span class="keyword">int</span>[]</span><br><span class="line">                          &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code>块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code>大括号之后缩进两个字符。每个<code>switch</code>标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        prepareOneOrTwo();</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        handleOneTwoOrThree();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default标签需要显式声明"><a href="#4-8-4-3-default标签需要显式声明" class="headerlink" title="4.8.4.3 default标签需要显式声明"></a>4.8.4.3 default标签需要显式声明</h5><p>每个<code>switch</code>语句中，都需要显式声明<code>default</code>标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的<code>switch</code>语句可以省略<code>default</code>语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接<code>Javadoc</code>之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>注解应用到成员变量时，也是紧接<code>Javadoc</code>之后。不同的是，多个注解可以放在同一行。例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用<code>/* */</code>进行注释，也可以用<code>//</code>进行注释。当使用<code>/* */</code>进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is</span></span><br><span class="line"><span class="comment"> * okay.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// And so</span></span><br><span class="line"><span class="comment">// is this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Or you can</span></span><br><span class="line"><span class="comment"> * even do this. */</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用<code>/* */</code>，<code>//</code>一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按<code>Java Lauguage Specification</code>中介绍的先后顺序排序。具体是：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">default</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的<code>L</code>作为后缀，不得使用小写（以免与数字1混淆）。例如：使用<code>3000000000L</code>，而不是<code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用<code>ASCII</code>字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用<code>com.example.deepspace</code>，而不是<code>com.example.deepSpace</code>或者<code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code>或者<code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语（例如：<code>Readable</code>）。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如：<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code>或者<code>stop</code>。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态<code>final</code>字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of(<span class="string">"Ed"</span>, <span class="number">35</span>, <span class="string">"Ann"</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>); <span class="comment">// 因为Joiner是不可变的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非常量</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableMap&lt;String, SomeMutableType&gt; mutableValues =</span><br><span class="line">    ImmutableMap.of(<span class="string">"Ed"</span>, mutableInstance, <span class="string">"Ann"</span>, mutableInstance2);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code>或者<code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写。</p><p>即使局部变量是<code>final</code>和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><strong>驼峰式命名法</strong>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯<code>ASCII</code>码，并且移除任何单引号。例如：<code>Müller’s algorithm</code>将变成<code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code>将分割成<code>ad words</code>)。 </li><li>需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter^</td><td>无</td></tr></tbody></table><p>加<code>^</code>号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code>和<code>non-empty</code>都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把<code>@Override</code>注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为<code>@Deprecated</code>时，可以省略<code>@Override</code>。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">    <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">    <span class="comment">// 它不是一个数字，不过没关系，继续</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    emptyStack.pop();</span><br><span class="line">    fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.3 静态成员：使用类来调用</p><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// 好</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// 糟</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// 很糟</span></span><br></pre></td></tr></table></figure><p>6.4 <code>Finalizers</code>: 禁用</p><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用<code>finalize</code>。如果你非要使用它，请先仔细阅读和理解<code>Effective Java第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code>块的基本格式如下所示：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>或者是以下单行形式：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure><p>基本格式总是可以接受的。当整个<code>Javadoc</code>块能容纳于一行时(且没有标记<code>@XXX</code>)，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和<code>Javadoc</code>标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进<code>4</code>个空格(<strong>注</strong>：如果你的缩进统一采用采用<code>4</code>个空格，那么这里就应该是<code>8</code>个空格)。</p><h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的<code>Javadoc</code>以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或者<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用Javadoc"><a href="#7-3-在哪里使用Javadoc" class="headerlink" title="7.3 在哪里使用Javadoc"></a>7.3 在哪里使用Javadoc</h3><p>至少在每个<code>public</code>类及它的每个<code>public</code>和<code>protected</code>成员处使用<code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，<code>Javadoc</code>是可选的(可以不写)。这种情况下除了写<code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么<code>Javadoc</code>并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用<code>Javadoc</code>的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成<code>Javadoc</code>，这样更统一更友好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Google-Java编程风格指南&quot;&gt;&lt;a href=&quot;#Google-Java编程风格指南&quot; class=&quot;headerlink&quot; title=&quot;Google Java编程风格指南&quot;&gt;&lt;/a&gt;Google Java编程风格指南&lt;/h1&gt;&lt;p&gt;标签： Java&lt;b
      
    
    </summary>
    
      <category term="Java代码之美" scheme="http://yoursite.com/categories/Java%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git Flow 工作模式</title>
    <link href="http://yoursite.com/2019/06/01/GitFlow%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/01/GitFlow工作模式/</id>
    <published>2019-05-31T18:35:49.381Z</published>
    <updated>2019-05-31T18:37:29.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-Flow-工作模式"><a href="#Git-Flow-工作模式" class="headerlink" title="Git Flow 工作模式"></a>Git Flow 工作模式</h1><p>以下为开发团队在落地敏捷开发过程中, 使用 <code>GitFlow</code> 工作模式, 总结的一些点.<br>由于我们也是在尝试探索, 一些地方可能还不太完善, 如发现不对的地方, 请在评论区指出或发起 <code>PR</code>.</p><p>发起任何 <code>Merge Request</code> (或称 <code>Pull Request</code>) 之前, 请参阅本文档作为核对表; 这将为每个人节省时间！</p><h2 id="了解基础知识"><a href="#了解基础知识" class="headerlink" title="了解基础知识"></a>了解基础知识</h2><p>不确定 <em>Merge Request</em> 是什么，或者如何提交 <em>Merge Request</em>?  看看 <strong>GitHub</strong> 的优秀文档：首先 <a href="https://help.github.com/articles/about-pull-requests/" target="_blank" rel="noopener">Using Pull Requests</a></p><h2 id="设置本地开发环境"><a href="#设置本地开发环境" class="headerlink" title="设置本地开发环境"></a>设置本地开发环境</h2><ol><li><p><code>git clone --recursive git@gitlab.thunisoft.com:Team_dzjz/FY_PRD_DZJZ_PRO.git parent</code></p></li><li><p><code>cd parent</code></p></li><li><p><code>git config user.name &#39;Your Name&#39;</code></p></li><li><p><code>git config user.email yourName@thunisoft.com</code></p></li><li><p><code>git config branch.autosetuprebase always</code> </p><blockquote><p>对于新建的分支都会设定 <code>rebase=true</code> 了.<br>已经创建好的分支还是需要手动配置 <code>git config branch.分支名.rebase true</code>.</p></blockquote></li><li><p><code>git flow init</code></p><blockquote><p>初始化你的本地 <code>Git Flow</code> 环境.<br>你必须回答几个关于分支的命名约定的问题. 建议使用默认值.<br>相关说明: <a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html</a></p></blockquote></li></ol><h2 id="保持本地代码同步"><a href="#保持本地代码同步" class="headerlink" title="保持本地代码同步"></a>保持本地代码同步</h2><p>!&gt; 请每天 <strong>至少执行一次</strong> 以下操作:</p><ul><li><p>在本地工作目录中, 您可以使用 <code>git fetch --all</code> 将所有远端的分支内容同步到本地.</p></li><li><p>如果在您工作时 <code>upstream/develop</code> 发生了更改，您可以再次同步: </p><ul><li>切换到主开发分支: <code>git checkout develop</code></li><li>更新代码: <code>git pull</code> 或 <code>git pull upstream master</code></li><li>切回工作分支: <code>git checkout feature/v4.2-xxx</code></li><li>重新定位主题分支, 以最小化它与您最近同步的主分支之间的距离(变基、rebase): <code>git rebease develop</code></li></ul><blockquote><p>或者也可以这么干: <code>git fetch origin &amp;&amp; git pull --rebase origin develop &amp;&amp; git rebase develop</code>, 避免来回切分支.<br>有关更多详细信息, 请参阅: <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA</a></p></blockquote></li><li><p><strong>警告</strong> 在执行 <code>rebase</code> 操作后, <strong>必须</strong> 使用 <code>git push --force</code> 或 <code>git push --force-with-lease</code> 进行推送.</p></li><li><strong>注意</strong> 通常建议不要使用重写历史记录 <code>git push --force</code>, 而应该使用 <code>git push --force-with-lease</code>.</li><li><strong>提示</strong> 必要时, 可以使用其他分支替代 <code>develop</code>, 如: 在 <code>release</code> 阶段, 个别分支 <em>应该</em> <code>rebase release/xx</code> 而不是 <code>rebase develop</code>.</li></ul><h2 id="保持线性提交历史记录"><a href="#保持线性提交历史记录" class="headerlink" title="保持线性提交历史记录"></a>保持线性提交历史记录</h2><p>合并到主分支时, 项目始终使用快进合并. 如上所述, 在发出拉取请求时, 请确保您的提交历史记录是线性的.</p><p>在命令行, 您可以使用一下命令检查: </p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline</span><br></pre></td></tr></table></figure><p>由于这样子命令比较长, 我们建议创建一个全局别名, 例如 <code>git logg</code>:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.logg <span class="string">'log --graph --pretty=oneline'</span></span><br></pre></td></tr></table></figure><p>此命令将提供以下输出, 在这种情况下显示一个很好的线性历史记录:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* c129a02e6c752b49bacd4a445092a44f66c2a1e9 INT-2721增加JDBC延迟器测试的计时器</span><br><span class="line">* 14e556ce23d49229c420632cef608630b1d82e7d INT-2620修复调试日志</span><br><span class="line">* 6140aa7b2cfb6ae309c55a157e94b44e5d0bea4f INT-3037完成后修复JDBC MS丢弃</span><br><span class="line">* 077f2b24ea871a3937c513e08241d1c6cb9c9179将Spring社交Twitter更新至1.0.5</span><br><span class="line">* 6d4f2b46d859c903881a561c35aa28df68f8faf3 INT-3053在&lt;reply-listener /&gt;上允许任务执行者</span><br><span class="line">* 56f9581b85a8a40bbcf2461ffc0753212669a68d将Spring社交Twitter版本更新至1.0.4</span><br></pre></td></tr></table></figure><p>如果你看到相交的线条, 这通常意味着你没有 <code>rebase</code> 最新主分支到你的分支. 如上说述, <strong>请</strong> 在发起合并请求之前 <code>rebase</code> 最新主分支到你的分支.</p><h2 id="遵循分支命名规范"><a href="#遵循分支命名规范" class="headerlink" title="遵循分支命名规范"></a>遵循分支命名规范</h2><p><strong>必须严格按照 <code>git flow</code> 的分支命名</strong></p><ul><li><code>master</code>, <code>develop</code> 这是工程初始化就已有或应有的分支, 若不存在, 请创建.</li><li><code>feature/根据功能尽量进行有意义的命名</code> 功能分支, 卷宗的开发一般都会带上当前 <code>在开发版本的版本号</code>, e.g. <code>feature/v4.2.1-fix-xxx</code>.</li><li><code>release/**</code> 用于稳定测试的分支, 从 develop 打出, 不在此分支上合并需求, 只改测试bug.</li><li><code>hotfix/**</code> 修改线上问题的分支.</li><li><code>bugfix/**</code> 开发过程非线上问题修改的分支.</li></ul><h2 id="遵循代码风格"><a href="#遵循代码风格" class="headerlink" title="遵循代码风格"></a>遵循代码风格</h2><p>请遵循：</p><ul><li><a href="http://artifacts.dzjz.pro/files/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6.pdf" target="_blank" rel="noopener">阿里云代码规约</a></li><li><a href="/#/Google%20Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97">Google Java编程风格指南</a></li></ul><h2 id="使用-since-标签"><a href="#使用-since-标签" class="headerlink" title="使用 @since 标签"></a>使用 <code>@since</code> 标签</h2><p><code>@since</code> 为新添加的公共 API 类型和方法使用标记, 例如:</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> First Last</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ......</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="使用-author-标签"><a href="#使用-author-标签" class="headerlink" title="使用 @author 标签"></a>使用 <code>@author</code> 标签</h2><p><code>@author</code> 当您更改任何类时，请使用带有您真实姓名的标签.</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> First Last</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="挤压提交-Squash-commits"><a href="#挤压提交-Squash-commits" class="headerlink" title="挤压提交(Squash commits)"></a>挤压提交(Squash commits)</h2><p>使用 <code>git rebase --interactive</code>，<code>git add --patch</code> 和其他工具, 以 “挤压” 多次提交到原子更改. 除了 <code>git</code> 的手册页之外, 还有许多在线资源可以帮助您了解这些工具的工作原理.</p><h2 id="在-git-提交中使用您的真实姓名或码名"><a href="#在-git-提交中使用您的真实姓名或码名" class="headerlink" title="在 git 提交中使用您的真实姓名或码名"></a>在 <code>git</code> 提交中使用您的真实姓名或码名</h2><p>请配置 <code>git</code> 以使用您要提交的任何提交的真实名字和姓氏作为拉取请求. 例如, 这是不可接受的:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Author: Nickname &lt;user@mail.com&gt;</span><br></pre></td></tr></table></figure><p>相反, 请提供正确大写的名字和姓氏:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Author: First Last &lt;user@mail.com&gt;</span><br></pre></td></tr></table></figure><p>这有助于确保对CLA的可追溯性, 并且还可以很长时间地确保来自 <code>git shortlog</code> 其他工具的有用输出.</p><p>全局的:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"First Last"</span></span><br><span class="line">git config --global user.email user@mail.com</span><br></pre></td></tr></table></figure><p>或者省略 <code>--global</code> 标记, 这种你情况下只在当前目录所在存储库有效:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">'Your Name'</span></span><br><span class="line">git config user.email yourName@thunisoft.com</span><br></pre></td></tr></table></figure><h2 id="为所有行为更改提交-JUnit-测试用例"><a href="#为所有行为更改提交-JUnit-测试用例" class="headerlink" title="为所有行为更改提交 JUnit 测试用例"></a>为所有行为更改提交 <code>JUnit</code> 测试用例</h2><p>搜索代码库以查找相关的单元测试并在其中添加其他 <code>@Test</code> 方法.</p><h2 id="在提交之前运行所有测试"><a href="#在提交之前运行所有测试" class="headerlink" title="在提交之前运行所有测试"></a>在提交之前运行所有测试</h2><p>有关说明，请参阅相关项目 <em>README</em> 的签出和构建部分. 确保在提交合并请求之前通过所有测试.</p><h2 id="开发及发布流程"><a href="#开发及发布流程" class="headerlink" title="开发及发布流程"></a>开发及发布流程</h2><ul><li>基于最新开发分支(develop), 拉取对应的 功能分支(feature).</li><li><p>待功能开发结束后, 执行以下操作:</p><ul><li><code>commit</code> 并 <code>push</code> 分支到 <code>GitLab</code> 服务器.</li><li>等待 <code>CI</code> 中的前置任务均成功后, 点击 <code>review</code> 进行测试环境的部署.</li><li>同时创建合并请求, 标记状态为 <code>WIP</code>. ps: 这时被指定人会收到通知, 将开始 <code>code-review</code>.</li><li>在评论区 @对应测试人员, 等待测试.</li><li>测试人员收到消息后, 应在对应环境中获取服务访问地址, 并进行测试, 若测试通过, <strong>不用回复测试完成</strong>, 直接取消合并请求中的 <code>WIP</code> 标记即可.</li><li>被指定为合并人的开发人员, 接受合并请求</li><li>一次功能开发流程完成.</li></ul><blockquote><p><code>线上问题修复</code> 流程类似, 基础分支 <strong>不是</strong> develop, 换成对应的发布 <strong>tag</strong> 即可.</p></blockquote></li><li><p>待所有功能分支均开发完成、测试完成、合并到 develop 后, 拉取 <code>预发布</code> 分支. e.g. release/1.0-rc1、release/1.0-rc2, 分别对应每一次 release 构建.</p><ul><li>敏捷开发模式下, 也可能是到达发布的时间点了, 就必须发布了, 没有开发完、测试完、合并到 develop 的分支, 等待下一个版本发布. ps: 一般不会超过两周.</li><li>拉取 release 分支后, develop 中的版本需要更新为下一版本. e.g. 1.1、2.0.</li><li>release 分支禁止提交, 如有 bug 修复, 需要新建对应 预发布版本问题修复分支(bugfix), 然后遵从如下流程:  </li></ul><blockquote><p>修改 -&gt; 提交 -&gt; 提测 -&gt; 测试通过 -&gt; 合并回 release 分支</p></blockquote><blockquote><p>ps: rc1 发现的 bug, 合并到 rc2, rc2 发现的 bug, 合并至 rc3, 以此类推, 直到测试通过</p></blockquote></li><li><p>基于预发布的分支, 生成一个对应版本的 <code>tag</code>. (e.g. 1.0) </p></li><li>将 release 分支合并到主分支: <code>master</code>, 同时删除 <code>release</code> 分支.</li><li>将 <code>develop</code> 快进至 <code>master</code>. ps: 其实就是 <code>rebase</code>.</li><li>至此, 一个版本周期结束</li><li>如无特殊情况, 一个版本周期最多为两周, 这版没发出去的, 不用急, 两周后下趟版本列车就来了.</li></ul><h2 id="合并请求流程"><a href="#合并请求流程" class="headerlink" title="合并请求流程"></a>合并请求流程</h2><ol><li>开发人员提起合并请求  在代码基本完成，测试人员介入之前就要提起合并请求，提起合并请求的时候标记 WIP (工作进行中)</li><li>主程审查代码，如果有疑问，主程开启问题讨论</li><li>开发人员修改测试问题和主程开启的讨论问题，commit 并 push 代码</li><li>开发人员提测试的时候，开启一个 <code>测试讨论</code> ，并@对应的测试人员</li><li>测试人员测试通过后，评论测试结果并关闭 <code>测试讨论</code>，可同时取消 WIP 状态</li></ol><p>上述流程中 <strong>不得</strong> 随意 <code>关闭</code> 当前合并请求后, <code>开启</code> 新的合并请求.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-Flow-工作模式&quot;&gt;&lt;a href=&quot;#Git-Flow-工作模式&quot; class=&quot;headerlink&quot; title=&quot;Git Flow 工作模式&quot;&gt;&lt;/a&gt;Git Flow 工作模式&lt;/h1&gt;&lt;p&gt;以下为开发团队在落地敏捷开发过程中, 使用 &lt;cod
      
    
    </summary>
    
      <category term="Git学习" scheme="http://yoursite.com/categories/Git%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/05/28/hello-world/"/>
    <id>http://yoursite.com/2019/05/28/hello-world/</id>
    <published>2019-05-28T14:45:55.044Z</published>
    <updated>2019-05-31T18:47:25.780Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Begin" scheme="http://yoursite.com/categories/Begin/"/>
    
    
      <category term="hello world" scheme="http://yoursite.com/tags/hello-world/"/>
    
  </entry>
  
</feed>
